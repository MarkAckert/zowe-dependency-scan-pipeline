#!groovy

/**
 * This program and the accompanying materials are made available under the terms of the
 * Eclipse Public License v2.0 which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-v20.html
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Copyright IBM Corporation 2020
 */


node('ibm-jenkins-slave-dind') {
  def PROJECT_BASE_DIR = "performance/client"
  def DEFAULT_ZMS_PORT = 19000

  // Test server configurations:
  // - credential id for ssh server hostname and port
  // - credential id for ssh username and password
  Map TEST_SERVERS = [
    'marist': [
      ssh_hostport     : 'ssh-marist-server-zzow01-hostport',
      ssh_userpass     : 'ssh-marist-server-zzow01',
      tmp_dir          : '/ZOWE/tmp',
      zms_dir          : '/ZOWE/tmp/zms',
      zms_credential   : 'ssh-marist-server-zzow01',
      // ZMS requires node v10+
      node_home        : '/ZOWE/node/node-v12.16.1-os390-s390x',
    ],
    'marist-2': [
      ssh_hostport     : 'ssh-marist-server-zzow02-hostport',
      ssh_userpass     : 'ssh-marist-server-zzow02',
      tmp_dir          : '/ZOWE/tmp',
      zms_dir          : '/ZOWE/tmp/zms',
      zms_credential   : 'ssh-marist-server-zzow02',
      // ZMS requires node v10+
      node_home        : '/ZOWE/node/node-v12.16.1-os390-s390x',
    ],
    'marist-3': [
      ssh_hostport     : 'ssh-marist-server-zzow03-hostport',
      ssh_userpass     : 'ssh-marist-server-zzow03',
      tmp_dir          : '/ZOWE/tmp',
      zms_dir          : '/ZOWE/tmp/zms',
      zms_credential   : 'ssh-marist-server-zzow03',
      // ZMS requires node v10+
      node_home        : '/ZOWE/node/node-v12.16.1-os390-s390x',
    ]
  ];

  def lib = library("jenkins-library").org.zowe.jenkins_shared_library

  def pipeline = lib.pipelines.nodejs.NodeJSPipeline.new(this)

  pipeline.admins.add("jackjia")

  // we have extra parameters for integration test
  pipeline.addBuildParameters(
    // >>>>>>>> parameters of where and what to test
    choice(
      name: 'TEST_SERVER',
      choices: TEST_SERVERS.keySet().collect(),
      description: 'Choose which server to run test'
    ),
    string(
      name: 'TEST_PORT',
      description: 'Service port to be tested. By default, this will be Zowe APIML Gateway port.',
      defaultValue: '7554',
      trim: true
    ),
    string(
      name: 'TEST_SCOPE',
      description: 'Test cases to be executed',
      defaultValue: 'dist/__tests__/default/idle/',
      trim: true
    ),
    booleanParam(
      name: 'UPDATE_PLOTS',
      description: 'If we should update dashboard plots.',
      defaultValue: false
    ),
    // >>>>>>>> parameters of artifactory
    string(
      name: 'ZMS_ARTIFACTORY_PATTERN',
      description: 'Zowe metrics server artifactory download pattern',
      defaultValue: 'libs-snapshot-local/org/zowe/metrics-server/*.pax',
      trim: true
    ),
    string(
      name: 'ZMS_ARTIFACTORY_BUILD',
      description: 'Zowe artifactory download build',
      defaultValue: 'Zowe Performance - Metrics Server :: master',
      trim: true
    ),
    string(
      name: 'REPORT_NAME',
      description: 'Report name published to Artifactory',
      defaultValue: 'report',
      trim: true
    ),
    // >>>>>>>> parametters for test cases
    string(
      name: 'PERFORMANCE_TEST_DEBUG_INFORMATION',
      description: 'How to show debug logging for running performance test cases.',
      defaultValue: 'zowe-performance-test:*',
      trim: true
    )
  )

  pipeline.setup(
    packageName    : 'org.zowe.performance-test-reports',
    baseDirectory  : PROJECT_BASE_DIR,
    nodeJsVersion  : 'v12.18.3',
    initWithColor  : true,
    auditWithColor : true,
    lintWithColor  : true
  )

  pipeline.build(displayAnsiColor: true)

  pipeline.test(
    name          : 'Performance',
    operation     : {
      withCredentials([
        usernamePassword(
          credentialsId: TEST_SERVERS[params.TEST_SERVER]['ssh_hostport'],
          passwordVariable: "SSH_PORT",
          usernameVariable: "SSH_HOST"
        ),
        usernamePassword(
          credentialsId: TEST_SERVERS[params.TEST_SERVER]['ssh_userpass'],
          passwordVariable: "SSH_PASSWORD",
          usernameVariable: "SSH_USER"
        ),
        usernamePassword(
          credentialsId: TEST_SERVERS[params.TEST_SERVER]['zms_credential'],
          passwordVariable: "RMF_DDS_PASSWORD",
          usernameVariable: "RMF_DDS_USERNAME"
        )
      ]) {
        def remote = [:]
        remote.name = params.TEST_SERVER
        remote.host = SSH_HOST
        remote.port = SSH_PORT
        remote.user = SSH_USER
        remote.password = SSH_PASSWORD
        remote.allowAnyHosts = true

        // download ZMS
        echo "Downloading ZMS ..."
        pipeline.artifactory.download(
          specContent : "{\n" +
                        "  \"files\": [{\n" +
                        "    \"pattern\": \"${params.ZMS_ARTIFACTORY_PATTERN}\",\n" +
                        "    \"target\": \".tmp/zms.pax\",\n" +
                        "    \"flat\": \"true\",\n" +
                        "    \"build\": \"${params.ZMS_ARTIFACTORY_BUILD}\"\n" +
                        "  }]\n" +
                        "}",
          expected    : 1
        )

        lock("performance-test-${params.TEST_SERVER}") {
          try {
            // prepare remote folders
            echo "Preparing remote folders ..."
            // sshCommand remote: remote, command: "mkdir -p ${TEST_SERVERS[params.TEST_SERVER]['tmp_dir']}"
            // sshCommand remote: remote, command: "rm -fr ${TEST_SERVERS[params.TEST_SERVER]['zms_dir']} && mkdir -p ${TEST_SERVERS[params.TEST_SERVER]['zms_dir']}"
            sh "SSHPASS=${remote.password} sshpass -e ssh -tt -o StrictHostKeyChecking=no -p ${remote.port} ${remote.user}@${remote.host} << EOF\n" +
               "mkdir -p ${TEST_SERVERS[params.TEST_SERVER]['tmp_dir']}\n" +
               "rm -fr ${TEST_SERVERS[params.TEST_SERVER]['zms_dir']}\n" +
               "mkdir -p ${TEST_SERVERS[params.TEST_SERVER]['zms_dir']}\n" +
               "exit 0\n" +
               "EOF"

            // transfer to the server
            echo "Uploading ZMS to ${TEST_SERVERS[params.TEST_SERVER]['tmp_dir']} ..."
            // sshPut remote: remote, from: '.tmp/zms.pax', into: TEST_SERVERS[params.TEST_SERVER]['tmp_dir']
            sh "SSHPASS=${remote.password} sshpass -e sftp -o BatchMode=no -o StrictHostKeyChecking=no -P ${remote.port} -b - ${remote.user}@${remote.host} << EOF\n" +
               "put .tmp/zms.pax ${TEST_SERVERS[params.TEST_SERVER]['tmp_dir']}\n" +
               "EOF"

            // extract ZMS
            // use SDSF metrics temporarily before RMF is configured
            // sshCommand remote: remote, command: "cd ${TEST_SERVERS[params.TEST_SERVER]['zms_dir']} && pax -rf ${TEST_SERVERS[params.TEST_SERVER]['tmp_dir']}/zms.pax && echo \"ls -la \$(pwd):\" && ls -la"
            echo "Extracting ZMS ..."
            //  "cp configs/sdsf-only.yaml configs/index.yaml\n" +
            sh "SSHPASS=${remote.password} sshpass -e ssh -tt -o StrictHostKeyChecking=no -p ${remote.port} ${remote.user}@${remote.host} << EOF\n" +
               "cd ${TEST_SERVERS[params.TEST_SERVER]['zms_dir']}\n" +
               "pax -rf ${TEST_SERVERS[params.TEST_SERVER]['tmp_dir']}/zms.pax\n" +
               "echo \"ls -la \\\$(pwd):\"\n" +
               "ls -la\n" +
               "exit 0\n" +
               "EOF"

            // start ZMS
            echo "Starting ZMS ..."
            sh "SSHPASS=${remote.password} sshpass -e ssh -tt -o StrictHostKeyChecking=no -p ${remote.port} ${remote.user}@${remote.host} << EOF\n" +
               "cd ${TEST_SERVERS[params.TEST_SERVER]['zms_dir']}\n" +
               "ZWS_PID=\\\$(ps -elf | grep zms | grep -v grep | awk '{print \\\$2;}')\n" +
               "[ -n \"\\\$ZWS_PID\" ] && echo \"Found ZMS PID: \\\${ZWS_PID}, send kill signal\" && kill -9 \\\$ZWS_PID\n" +
               "[ -f ~/.profile ] && . ~/.profile\n" +
               "export NODE_HOME=${TEST_SERVERS[params.TEST_SERVER]['node_home']}\n" +
               "export _BPXK_AUTOCVT=ON\n" +
               "export _CEE_RUNOPTS=\"FILETAG(AUTOCVT,AUTOTAG) POSIX(ON)\"\n" +
               "export RMF_DDS_HOST=\"${remote.host}\"\n" +
               "export RMF_DDS_USERNAME=\"${RMF_DDS_USERNAME}\"\n" +
               "export RMF_DDS_PASSWORD=\"${RMF_DDS_PASSWORD}\"\n" +
               "nohup ./bin/start.sh &\n" +
               "exit 0\n" +
               "EOF"

            // wait for a minute to let system cool down
            echo "Waiting for cool down ..."
            sleep time: 1, unit: 'MINUTES'

            // start test
            def testEnvVars = [
              "FORCE_COLOR=true",
              "DEBUG=${params.PERFORMANCE_TEST_DEBUG_INFORMATION}".toString(),
              "ZMS_HOST=${SSH_HOST}".toString(),
              "ZMS_PORT=${DEFAULT_ZMS_PORT}".toString(),
              "TARGET_HOST=${SSH_HOST}".toString(),
              "TARGET_PORT=${params.TEST_PORT}".toString(),
              "TEST_AUTH_USER=${SSH_USER}".toString(),
              "TEST_AUTH_PASSWORD=${SSH_PASSWORD}".toString(),
            ]
            echo "Environment variables: ${testEnvVars}"
            echo "Starting test ..."
            withEnv(testEnvVars) {
              ansiColor('xterm') {
                pipeline.nvmShell("npm run test ${params.TEST_SCOPE}")
              }
            } // end of withEnv
          } catch (ex) {
            error "Test failed with error: ${ex}"
          } finally {
            // show what's in .tmp for debugging purpose
            echo "Content of .tmp:"
            sh 'ls -la .tmp'

            // shutdown ZMS
            echo "Shutting down ZMS ..."
            sh "SSHPASS=${remote.password} sshpass -e ssh -tt -o StrictHostKeyChecking=no -p ${remote.port} ${remote.user}@${remote.host} << EOF\n" +
               "cd ${TEST_SERVERS[params.TEST_SERVER]['zms_dir']}\n" +
               "[ -f nohup.out ] && chtag -tc819 nohup.out && echo \"Output of ZMS:\" && cat nohup.out\n" +
               "ZWS_PID=\\\$(ps -elf | grep zms | grep -v grep | awk '{print \\\$2;}')\n" +
               "[ -n \"\\\$ZWS_PID\" ] && echo \"Found ZMS PID: \\\${ZWS_PID}, send kill signal\" && kill -9 \\\$ZWS_PID\n" +
               "exit 0\n" +
               "EOF"
          }
        } // end of lock
      } // end of withCredentials
    },
    allowMissingJunit : true,
    timeout           : [time: 4, unit: 'HOURS']
  )

  // define we need publish stage
  pipeline.publish(
    name: "Test Report",
    shouldExecute: {
      // FIXME: shouldExecute closure doesn't take global baseDirectory
      dir(PROJECT_BASE_DIR) {
        sh "ls -la reports"
        def reports = findFiles(glob: "reports/*.yaml")
        if (reports.length <= 0) {
          echo "No reports found"
          return false
        } else if (reports.length > 1) {
          echo "More than 1 report found"
          return false
        } else {
          // rename
          sh "mv ${reports[0].toString()} reports/${params.REPORT_NAME}.yaml"
          return true
        }
      }
    },
    operation: {
      echo "Default npm publish will be skipped."
    },
    artifacts: [
      "reports/*.yaml"
    ]
  )


  pipeline.createStage(
    name: "Chart Report",
    isSkippable: false,
    baseDirectory  : PROJECT_BASE_DIR,
    stage: {
      echo "Content of reports/:"
      sh "ls -la reports/"
      def reports = findFiles(glob: "reports/*.yaml")
      if (reports.length == 1) {
        reportFile = reports[0]

        def htmlReport = "<!DOCTYPE html>\n" +
            "<html>\n" +
            "<head>\n" +
            "  <script src=\"https://code.highcharts.com/highcharts.js\"></script>\n" +
            "  <script src=\"https://code.highcharts.com/modules/data.js\"></script>\n" +
            "  <script src=\"https://code.highcharts.com/modules/exporting.js\"></script>\n" +
            "</head>\n" +
            "<body>\n"
        def jsReport = "document.addEventListener('DOMContentLoaded', function () {\n" +
            "var baseUrl = window.location.origin + window.location.pathname.substring(0, window.location.pathname.lastIndexOf('/'));\n"

        // what metric we want to display
        def regex = /^cpu\{.+,(?:item|process)="([^"]+)",(?:jobid|extra)="([^"]+)"\}$/

        htmlReport += "<h1>Test ${reportFile.toString()}</h1>\n"
        echo "Processing report ${reportFile.toString()} ..."
        def report = readYaml(file: reportFile.toString())
        def testIndex = 0
        report.tests.each { test ->
          testIndex = testIndex + 1
          echo "Processing test ${test.name} ..."
          if (test["serverMetrics"] && test["serverMetrics"].size()) {
            def sanitizedTestName = test.name.toLowerCase().replaceAll(/[^0-9a-zA-Z]/, "-")
            def csvFile = sanitizedTestName + ".csv"
            def plotFile = "plot-" + sanitizedTestName + ".csv"
            echo "- Preparing CSV ${csvFile} ..."

            // prepare columns and row indexes (timestamp)
            def csvColumns = []
            def csvRowIndexes = []
            test.serverMetrics.each { metric ->
              def matches = metric.name =~ regex
              if (matches.matches() && matches[0] && matches[0].size() == 3) {
                def process = matches[0][1]
                def extra = matches[0][2]
                def colname = "${process}${extra ? "(${extra})" : ""}"
                if (!csvColumns.contains(colname)) {
                  csvColumns.add(colname)
                }

                if (!csvRowIndexes.contains(metric.timestamp)) {
                  csvRowIndexes.add(metric.timestamp)
                }
              }
            }
            csvColumns.sort().add(0, "Timestamp")
            csvRowIndexes.sort()

            // create map because indexOf requires special privileges
            def totalCols = csvColumns.size()
            def totalRows = csvRowIndexes.size()
            def csvColumnsMap = [:]
            def csvRowIndexesMap = [:]
            for (i = 0; i < totalCols; i++) {
                csvColumnsMap["${csvColumns[i]}".toString()] = i
            }
            for (i = 0; i < totalRows; i++) {
                csvRowIndexesMap["${csvRowIndexes[i]}".toString()] = i
            }

            // init result rows
            def csvRows = []
            csvRowIndexes.each { ts ->
              def row = []
              for (i = 0; i < totalCols; i++) {
                row.add(i == 0 ? ts : null)
              }
              csvRows.add(row)
            }

            // fill in data
            test.serverMetrics.each { metric ->
              def matches = metric.name =~ regex
              if (matches.matches() && matches[0] && matches[0].size() == 3) {
                def process = matches[0][1]
                def extra = matches[0][2]
                def colname = "${process}${extra ? "(${extra})" : ""}"
                def col = csvColumnsMap[colname]
                def row = csvRowIndexesMap["${metric.timestamp}".toString()]
                csvRows[row][col] = metric.value
              }
            }

            // calculate delta
            for (i = csvRows.size() - 1; i >= 0; i--) {
              for (j = 1; j < csvRows[i].size(); j++) {
                if (i > 0) {
                  csvRows[i][j] -= csvRows[i - 1][j]
                } else {
                  csvRows[i][j] = 0
                }
              }
            }

            // write csv file
            echo "- writing CSV ..."
            def result = []
            result.add("\"" + csvColumns.join("\",\"") + "\"")
            csvRows.each {
              result.add(it.join(","))
            }
            echo result.join("\n")
            writeFile file: "reports/${csvFile}", text: result.join("\n")

            def plotCsvContent = []
            htmlReport += "<h2>${test.name}</h2>\n" +
              "<ul>\n"
            if (test.result && test.result.total_cpu_percentage_from_server_metrics) {
              htmlReport += "<li><strong>Test Duration<strong>: ${test.result.total_time_elapse_from_server_metrics}</li>\n"
              htmlReport += "<li><strong>Total CPU Time<strong>: ${test.result.total_cpu_time_from_server_metrics}</li>\n"
              htmlReport += "<li><strong>Average CPU %<strong>: ${test.result.total_cpu_percentage_from_server_metrics}%</li>\n"

              plotCsvContent.push('"Build","Average CPU %","Total CPU Time","Duration"')
              plotCsvContent.push("${BUILD_NUMBER},${test.result.total_cpu_percentage_from_server_metrics},${test.result.total_cpu_time_from_server_metrics},${test.result.total_time_elapse_from_server_metrics}")
            }
            htmlReport += "</ul>\n"

            // highcharts script to generate chart for this test
            htmlReport += "\n" +
              "<div id=\"container_${testIndex}\" style=\"width:80%; height:400px; margin: auto;\"></div>\n"
            jsReport += "\n" +
              "  Highcharts.chart('container_${testIndex}', {\n" +
              "    chart: { type: 'line' },\n" +
              "    data: { csvURL: baseUrl + '/${csvFile}' },\n" +
              "    title: { text: '${test.name}' },\n" +
              "    yAxis: { title: { text: 'CPU Time Delta' } }\n" +
              "  });\n"

            if (params.UPDATE_PLOTS) {
              // write plot file
              echo "- writing ${plotFile} ..."
              echo plotCsvContent.join("\n")
              writeFile file: "reports/${plotFile}", text: plotCsvContent.join("\n")

              // generate plot graph
              plot csvFileName: 'plot-84918970-489a-4cec-ac00-b1181f145849.csv',
                csvSeries: [[
                  displayTableFlag: true,
                  file: "reports/${plotFile}",
                  inclusionFlag: 'INCLUDE_BY_STRING',
                  exclusionValues: 'Average CPU %'
                ]],
                group: 'Performance Dashoard',
                numBuilds: '20',
                style: 'line',
                title: "${test.name}",
                yaxis: 'Time (s)'
            }
          }
        }

        if (testIndex > 0) {
          // write test report
          echo "Saving test report"
          htmlReport += "<script src=\"main.js\"></script>\n" +
            "</body>\n" +
            "</html>"
          writeFile file: "reports/index.html", text: htmlReport
          jsReport += "});"
          writeFile file: "reports/main.js", text: jsReport
          publishHTML([
            allowMissing          : false,
            alwaysLinkToLastBuild : true,
            keepAll               : true,
            reportDir             : 'reports',
            reportFiles           : 'index.html',
            reportName            : 'Test Result Charts',
            reportTitles          : ''
          ])
        }
      }
    }
  )

  pipeline.end()
}
